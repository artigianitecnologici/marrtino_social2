#!/usr/bin/python
# -*- coding: utf-8 -*-
import rospy
from std_msgs.msg import String
import threading
import requests
import sys, os
import time
import socket
import random
import json  # Import per decodifica JSON

from threading import Thread

SERVER_ADDRESS = '10.3.1.1'
SERVER_PORT = 9000

sys.path.append(os.getenv("MARRTINO_APPS_HOME")+"/program")
from robot_cmd_ros import *

myurl = 'http://10.3.1.1:5000/bot'
TOPIC_nroface = "/social/face_nroface"
TOPIC_gesture = "/social/gesture"
TOPIC_speech = "/speech/to_speak"
TOPIC_emotion = "/social/emotion"
TOPIC_speechstatus = "/speech/status"
TOPIC_response_gtp = "/gtpresponse"
TOPIC_request_gtp = "/gtprequest"

tracking = False

gesture_pub = rospy.Publisher(TOPIC_gesture, String, queue_size=10)
emotion_pub = rospy.Publisher(TOPIC_emotion, String, queue_size=1, latch=True)
gpt_request_publisher = rospy.Publisher(TOPIC_request_gtp, String, queue_size=10)

# Funzione di connessione socket con gestione degli errori e timeout
def create_server_socket(server_address, server_port, retries=5, retry_delay=5):
    while retries > 0:
        try:
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_socket.bind((server_address, server_port))
            server_socket.listen(1)
            server_socket.settimeout(10.0)  # Imposta un timeout di 10 secondi
            print("Server listening on (%s, %d)" % (server_address, server_port))
            return server_socket
        except socket.error as e:
            if e.errno == 98:  # Address already in use
                print("Errore: Indirizzo già in uso. Riprovo a collegarmi tra %d secondi..." % retry_delay)
                time.sleep(retry_delay)
                retries -= 1
            else:
                print("Errore di socket: %s" % e)
                raise e
    raise RuntimeError("Impossibile avviare il server socket dopo vari tentativi")

# Definizione della funzione di callback per gestire le risposte GPT
def callback_gtpresponse(msg):
    try:
        json_data = json.loads(msg.data)
        rospy.loginfo("Messaggio decodificato ricevuto:")
        rospy.loginfo(json.dumps(json_data, indent=4, ensure_ascii=False))

        status = json_data.get("status", "N/A")
        msg_field = json_data.get("msg", "N/A")
        error = json_data.get("error", "N/A")
        data = json_data.get("data", {})
        action = json_data.get("action", "N/A")

        macro_vr = data.get("macro_vr", [])
        emotion = data.get("emotion", [])
        language = data.get("language", [])
        speech = data.get("speech", [])
        head = data.get("head", [])
        gesture = data.get("gesture", [])
        wait = data.get("wait", [])
        url = data.get("url", [])
        message = data.get("message", "N/A")

        rospy.loginfo("Status: %s" % status)
        rospy.loginfo("Msg: %s" % msg_field)
        rospy.loginfo("Error: %s" % error)
        rospy.loginfo("Action: %s" % action)
        rospy.loginfo("Macro VR: %s" % macro_vr)
        rospy.loginfo("Emotion: %s" % emotion)
        rospy.loginfo("Language: %s" % language)
        rospy.loginfo("Speech: %s" % speech)
        rospy.loginfo("Head: %s" % head)
        rospy.loginfo("Gesture: %s" % gesture)
        rospy.loginfo("Wait: %s" % wait)
        rospy.loginfo("URL: %s" % url)
        rospy.loginfo("Message: %s" % message)

    except json.JSONDecodeError:
        rospy.logerr("Errore nella decodifica del messaggio JSON")

# Sottoscrizione al topic per le risposte GPT
gpt_response_sub = rospy.Subscriber(TOPIC_response_gtp, String, callback_gtpresponse)

def emotion(msg):
    print('social/emotion %s' % msg)
    emotion_pub.publish(msg)

def gpt_request_pub(msg):
    print('gpt_request_pub %s' % msg)
    gpt_request_publisher.publish(msg)

##########################
# FUNZIONI PERSONALIZZATE
def key_room():
    emotion("happy")
    say('Ecco la chiave della sua stanza, la prego di prenderla', 'it')
    head_position("left")
    left_shoulder_flexion(20)
    left_shoulder_rotation(20)
    left_elbow(40)
    left_hand(-70)
    emotion("normal")
    wait(4)
    say('Le ricordo che il servizio in camera è dalle 7 alle 9. Se vuole ulteriori informazioni può consultare il sito', 'it')
    wait(9)
    head_position("front")
    gesture("init")

def bot(msg):
    payload = {'query': msg}
    response = requests.get(url=myurl, params=payload)
    content = response.content
    return content

def left(s, n):
    return s[:n]

def gesture(msg):
    gesture_pub.publish(msg)

def reset_face():
    rospy.loginfo("resetting face")

def speech(msg, language):
    say(msg, language)
    gesture('gesture')

def callback_speechstatus(data):
    global stspeech
    stspeech = data.data
    if stspeech == "STOP":
        emotion("normal")
    if stspeech == "START":
        emotion("speak")
    rospy.loginfo(stspeech)

def timerping():
    threading.Timer(10.0, timerping).start()
    print("Ciao mondo!")

def callback(data):
    global tracking
    if data.data == 0 and tracking:
        tracking = False
    elif data.data != 0 and not tracking:
        tracking = True
        speech("ciao")

def command(msg):
    print(msg)
    t = Thread(target=run_code, args=(msg,))
    t.start()
    return "ok"

def listener():
    mylanguage = "it"
    begin()
    print("Interactive Mode Start")
    reset_face()
    emotion("startblinking")
    gesture("gesture")
    speech("Ciao sono martina", mylanguage)
    speech("Apri l'applicazione e parla con me", mylanguage)

    # Utilizzo della funzione che gestisce gli errori del socket
    serverSocket = create_server_socket(SERVER_ADDRESS, SERVER_PORT)

    while True:
        try:
            connectionSocket, clientAddress = serverSocket.accept()
            connectionSocket.settimeout(10.0)  # Imposta un timeout per la connessione
            print("Connessione accettata da %s" % str(clientAddress))

            while True:
                try:
                    myrequest = connectionSocket.recv(1024)
                except socket.timeout:
                    print("Timeout nella ricezione dei dati")
                    continue

                if myrequest:
                    print(myrequest)
                    keyword = "martina"
                    msglenght = len(myrequest)
                    keylenght = len(keyword)
                    mycommand = ""
                    if left(myrequest.lower(), keylenght) == keyword:
                        mycommand = myrequest[keylenght + 1:msglenght].lower()

                        # Controlli sui comandi, esegui il codice corrispondente

                    if myrequest == "stop" or myrequest == "fine":
                        speech("ci vediamo alla prossima", mylanguage)
                        break

                    if myrequest == "PING":
                        connectionSocket.send("PONG")

                    if myrequest and not mycommand:
                        connectionSocket.send("STOP")
                        answer = bot(myrequest)
                        gesture("gesture")
                        speech(answer, mylanguage)
                        connectionSocket.send("SAY")

        except socket.timeout:
            print("Timeout durante l'attesa di una connessione, riprovo...")

        except Exception as e:
            print("Errore: %s" % e)
            continue  # Continua ad accettare altre connessioni in caso di errore

        finally:
            connectionSocket.close()

# Avvio del listener
listener()
